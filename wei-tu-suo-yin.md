每个具体的位图， 其可能的取值相对于数据总量来说往往并不多， 但是查询经常涉及到很多维度的组合。举个例子， 假设数据是中国的人口数据， 有一个维度是年龄。 那么这个维度的可能值不会超过150个， 还有一个维度是所在区域， 如果省级区域的话也就三十来个。维度本身的取值不多， 可是查询的时候往往是一种组合。 比如青海省20-30岁之间的人。 那么能快速适应这类查询的技术就是位图索引。 下面介绍一下位图索引。请大家注意， 我们讨论过程假设数据和索引都在内存， 因为如果涉及机械盘的随机IO， 情况就会发生变化。



假设我们有64条数据编号分别为1到64，每条数据都表示一个人口信息， 有这个人的年龄， 所属区域， 性别等属性。那么我们可以对所有在青海地区的人建立一个位图索引。使用一个64为的int， 每一位对应一条数据， 如果这个人是青海的， 对应的位就置1， 否则置0. 然后我们再对这组数据的性别建立位图索引， 同理， 男的置1，女的置0.



现在我们要查询青海地区的男性， 怎么做呢？ 只要上面两个位图做&操作就可以了。位图索引可以很方便的完成这些操作， 可是位图索引太大了， 属性值上大部分数据都是0， 所以位图索引可以压缩。好消息是只要压缩方法得当， 压缩后的位图索引仍旧能够进行位操作。 详细信息请查询相关文献（去google 上搜 concise compress）。





特别提到大家要考虑数据和索引都在内存中， 这是因为数据本身无法做到按照维度连续存储（维度太多了， 不可能让数据冗余那么多份）。所以通过位图索引查找后， 取元数据的过程还是一个随机访问过程。而磁盘的随机IO性能实在太差。



大家回顾一下druid 总体介绍的时候提到 historical node 会把数据从 deep storage 中 load 到本地。除非你本地使用ssd， 不然还是配置足够的内存，保证 historical node 可以把数据都 load 到内存中吧。



